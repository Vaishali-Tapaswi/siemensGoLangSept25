
Lab4 - Testing 
	create a new folder (demo5)
	create Lab1.go 
		package main 

		import (
			"fmt"
		)
		
		func main(){
			fmt.Println(Add(300,100))
			fmt.Println(Divide(300,100))
			fmt.Println(Divide(300,0))
		}
		func Add(no1, no2 int) int {
			return no1+no2
		}
		func Divide(no1 , no2 int ) (int) {
			return no1/no2;
		}
	create Lab1_test.go 
		package main 
		import (
		//	"fmt"
			"testing"
		)
		
		func TestAdd(t *testing.T){
			got := Add(4000,3000)
		    if got != 7000 {
		        t.Errorf("Add(4000,3000) = %d; want 7000", got)
		    }
		}
		
		func TestDivide(t *testing.T){
			got := Divide(4000,400)
		    if got != 10 {
		        t.Errorf("Divide(4000,400) = %d; want 10", got)
		    }
		}
		func TestDivide1(t *testing.T){
			defer func(){
				if r:= recover(); r == nil{
					t.Errorf("Divide(4000,00) should create panic call")
				}
			}()
			Divide(4000,0)
		}
	cmd>go test  Lab1_test.go 
		check error
	cmd>go test  Lab1_test.go  Lab1.go 
		run successfully (just 1 line of info)
	cmd>go test -v Lab1_test.go  Lab1.go  
		verbose output of all tests
	cmd>go mod init test 
	cmd>go test . 
	cmd>

	Coverage (how many methods or code lines are tested 
	cmd>go test -v . -cover
		show %age of coverage without details
	cmd>go test -v ..test.go  -coverprofile tmp.txt
    	check tmp.txt file getting created
    cmd>go tool cover -html=tmp.txt -o tmp.html
		open tmp.html in browser 
	

Lab3 - Mutex + wg 
package main

import (
	"fmt"
	"time"
	"sync"
)

const counter = 100

type Bank struct {
	balance float64	
	mymutext sync.Mutex
}

func (b *Bank) Increament(amount float64) {
	b.mymutext.Lock()
	defer b.mymutext.Unlock()
	for j := 0; j < counter; j++ {
		tmp := b.balance + amount
		time.Sleep(1 * time.Millisecond)	
		b.balance = tmp
	}
	fmt.Println("In Increment - current balance is ", b.balance)
}

func (b *Bank) Decrement(amount float64) {
	b.mymutext.Lock()
	defer b.mymutext.Unlock()
	
	for j := 0; j < counter; j++ {
		tmp := b.balance - amount
		time.Sleep(1 * time.Millisecond)	
		b.balance = tmp
	}
	fmt.Println("In Decrement - current balance is ", b.balance)
}

func main() {
	var wg sync.WaitGroup
	bank := Bank{balance: 0.0}
	wg.Add(1)
	wg.Add(1)

	go func(){
		defer wg.Done()
		bank.Increament(1)
	}()
	go func(){
		defer wg.Done()
		bank.Decrement(1)
	}()
	
	fmt.Println("before wait")
	wg.Wait()
	fmt.Println("after wait")
	fmt.Printf("Final balance for account is %.2f\n", bank.balance)
	
}


Lab2 - why synchronization
package main

import (
	"fmt"
	"time"
)

const counter = 100

type Bank struct {
	balance float64	
}

func (b *Bank) Increament(amount float64) {
	for j := 0; j < counter; j++ {
		tmp := b.balance + amount
		time.Sleep(5 * time.Millisecond)
		b.balance = tmp
	}
	fmt.Println("In Increment - current balance is ", b.balance)
}

func (b *Bank) Decrement(amount float64) {
	for j := 0; j < counter; j++ {
		tmp := b.balance - amount
		time.Sleep(5 * time.Millisecond)	
		b.balance = tmp
	}
	fmt.Println("In Decrement - current balance is ", b.balance)
}

func main() {
	bank := Bank{balance: 00.0}
	for i := 0; i < 5; i++ {
		go bank.Increament(1)
		go bank.Decrement(1)
	}
	time.Sleep(5 * time.Second)
	fmt.Printf("Final balance for account is %.2f\n", bank.balance)
}


Lab1 - goroutine interaction, range for channel reading 
package main 
import (
	"fmt"
	"strconv"
)
const count=50

func main(){
		ch := make(chan string)
		go write(ch)
		go read(ch)
		for{

		}
}

func read(ch1 chan string){
	/*Option for fixed number of messages
	for i:=1;i<5;i++{
		fmt.Println("Reading data on channel")
		str := <-ch1 
		fmt.Println("Received   " + str)
	}
	*/
	for msg := range ch1 {
		fmt.Println("Reading data on channel")
		fmt.Println("Received   " + msg)
	}
	close(ch1)

}
func write(ch1 chan string){
	// in for loop write data to channel 
	for i:=1;i<count;i++{
		fmt.Println("Sending data to channel " , i)
		ch1 <- "str"+strconv.Itoa(i)
		fmt.Println("Finished sending data to channel " , i)
	}
	
}
