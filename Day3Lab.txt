Lab8 - https://go.dev/blog/using-go-modules
Lab 
	create a folder (demo7)
		create two folder - demo7\mylib
							demo7\libuser 
		create calc.go in demo7\mylib 
			package calc
			import "fmt"
			func Hello(str string) string{
				fmt.Println("in calc.hello with " , str)
				return "Hello, "+ str
			}
			func Add(no1, no2 int) int {
				fmt.Println("in calc add with ", no1, " ", no2)
				return no1+no2
			}
		try doing go run calc.go
		cmdmylib>>go mod init calc
		cmdmylib>>go mod tidy
	
		create Lab1.go in demo7\libuser
		package main 
		import(
			"fmt"
			"calc"
		)

		func main(){
			fmt.Println("in Lab1 of libuser")
			str := calc.Hello("Vaishali")
			fmt.Println(str)
			num := calc.Add(1000,4000)
			fmt.Println("Sum = ", num)
		}
		cmdlibuser>go mod init executable
		cmdlibuser>go mod tidy
		cmdlibuser>go mod edit -replace calc=../mylib
		cmdlibuser>go mod tidy 
		cmdlibuser>go run Lab1.go

Lab7 - modify 
		emp add method to include db insertion( with params)func (db *DB) Exec(query string, args ...any) (Result, error)
			modify to pass 3 args in sql 
		modify emp list method to read data (func (db *DB) QueryRow(query string, args ...any) *Row)

Lab6 - Modify current code and dependencies to connect to mysql -> observe errors, create database, create table 
package main

import (
	"database/sql"
	"fmt"
	_ "github.com/go-sql-driver/mysql"
)

type Emp struct {
	EmpNo  int     `json:"empno"`
	Name   string  `json:"name"`
	Salary float64 `json:"sal"`
}

type EmpDao struct {
	emps []Emp
}

func (dao *EmpDao) add(emp Emp) {
	fmt.Println("add invoked", emp)
}

func (dao *EmpDao) list() {
	fmt.Println("list invoked ")
}

func main() {

	connStr:="admin:@tcp(mysqldb1.cora8c66s2x6.us-east-1.rds.amazonaws.com:3306)/dbname"
	
	db, err := sql.Open("mysql", connStr)
	
	if err != nil {
		fmt.Println("Error ", err)
	}
	fmt.Println("Done with open")
	result, err := db.Exec("insert into EmpTable values(1, 'aaaa',1111.11)")
	fmt.Println("Result", result)
	fmt.Println("Error after insert ", err)

}


Lab5- Create a folder demo6
		Create code to establish connection to postgres
package main

import (
	"database/sql"
	"fmt"
	_ "github.com/lib/pq"
)

type Emp struct {
	EmpNo  int     `json:"empno"`
	Name   string  `json:"name"`
	Salary float64 `json:"sal"`
}

type EmpDao struct {
	emps []Emp
}

func (dao *EmpDao) add(emp Emp) {
	fmt.Println("add invoked", emp)
}

func (dao *EmpDao) list() {
	fmt.Println("list invoked ")
}

func main() {

	connStr := "postgres://postgres:MyPassword@database-1.cora8c66s2x6.us-east-1.rds.amazonaws.com/mydb?sslmode=disable"
	db, err := sql.Open("postgres", connStr)
	if err != nil {
		fmt.Println("Error ", err)
	}
	fmt.Println(db)
	//func (db *DB) Exec(query string, args ...any) (Result, error)
	result, err := db.Exec("insert into EmpTable values(1, 'aaaa',1111.11)")
	fmt.Println("Result", result)
	fmt.Println("Error after insert ", err)
}

	create a module 
	install dependencies
	run code to check errors


Lab4 - Testing 
	create a new folder (demo5)
	create Lab1.go 
		package main 

		import (
			"fmt"
		)
		
		func main(){
			fmt.Println(Add(300,100))
			fmt.Println(Divide(300,100))
			fmt.Println(Divide(300,0))
		}
		func Add(no1, no2 int) int {
			return no1+no2
		}
		func Divide(no1 , no2 int ) (int) {
			return no1/no2;
		}
	create Lab1_test.go 
		package main 
		import (
		//	"fmt"
			"testing"
		)
		
		func TestAdd(t *testing.T){
			got := Add(4000,3000)
		    if got != 7000 {
		        t.Errorf("Add(4000,3000) = %d; want 7000", got)
		    }
		}
		
		func TestDivide(t *testing.T){
			got := Divide(4000,400)
		    if got != 10 {
		        t.Errorf("Divide(4000,400) = %d; want 10", got)
		    }
		}
		func TestDivide1(t *testing.T){
			defer func(){
				if r:= recover(); r == nil{
					t.Errorf("Divide(4000,00) should create panic call")
				}
			}()
			Divide(4000,0)
		}
	cmd>go test  Lab1_test.go 
		check error
	cmd>go test  Lab1_test.go  Lab1.go 
		run successfully (just 1 line of info)
	cmd>go test -v Lab1_test.go  Lab1.go  
		verbose output of all tests
	cmd>go mod init test 
	cmd>go test . 
	cmd>

	Coverage (how many methods or code lines are tested 
	cmd>go test -v . -cover
		show %age of coverage without details
	cmd>go test -v ..test.go  -coverprofile tmp.txt
    	check tmp.txt file getting created
    cmd>go tool cover -html=tmp.txt -o tmp.html
		open tmp.html in browser 
	

Lab3 - Mutex + wg 
package main

import (
	"fmt"
	"time"
	"sync"
)

const counter = 100

type Bank struct {
	balance float64	
	mymutext sync.Mutex
}

func (b *Bank) Increament(amount float64) {
	b.mymutext.Lock()
	defer b.mymutext.Unlock()
	for j := 0; j < counter; j++ {
		tmp := b.balance + amount
		time.Sleep(1 * time.Millisecond)	
		b.balance = tmp
	}
	fmt.Println("In Increment - current balance is ", b.balance)
}

func (b *Bank) Decrement(amount float64) {
	b.mymutext.Lock()
	defer b.mymutext.Unlock()
	
	for j := 0; j < counter; j++ {
		tmp := b.balance - amount
		time.Sleep(1 * time.Millisecond)	
		b.balance = tmp
	}
	fmt.Println("In Decrement - current balance is ", b.balance)
}

func main() {
	var wg sync.WaitGroup
	bank := Bank{balance: 0.0}
	wg.Add(1)
	wg.Add(1)

	go func(){
		defer wg.Done()
		bank.Increament(1)
	}()
	go func(){
		defer wg.Done()
		bank.Decrement(1)
	}()
	
	fmt.Println("before wait")
	wg.Wait()
	fmt.Println("after wait")
	fmt.Printf("Final balance for account is %.2f\n", bank.balance)
	
}


Lab2 - why synchronization
package main

import (
	"fmt"
	"time"
)

const counter = 100

type Bank struct {
	balance float64	
}

func (b *Bank) Increament(amount float64) {
	for j := 0; j < counter; j++ {
		tmp := b.balance + amount
		time.Sleep(5 * time.Millisecond)
		b.balance = tmp
	}
	fmt.Println("In Increment - current balance is ", b.balance)
}

func (b *Bank) Decrement(amount float64) {
	for j := 0; j < counter; j++ {
		tmp := b.balance - amount
		time.Sleep(5 * time.Millisecond)	
		b.balance = tmp
	}
	fmt.Println("In Decrement - current balance is ", b.balance)
}

func main() {
	bank := Bank{balance: 00.0}
	for i := 0; i < 5; i++ {
		go bank.Increament(1)
		go bank.Decrement(1)
	}
	time.Sleep(5 * time.Second)
	fmt.Printf("Final balance for account is %.2f\n", bank.balance)
}


Lab1 - goroutine interaction, range for channel reading 
package main 
import (
	"fmt"
	"strconv"
)
const count=50

func main(){
		ch := make(chan string)
		go write(ch)
		go read(ch)
		for{

		}
}

func read(ch1 chan string){
	/*Option for fixed number of messages
	for i:=1;i<5;i++{
		fmt.Println("Reading data on channel")
		str := <-ch1 
		fmt.Println("Received   " + str)
	}
	*/
	for msg := range ch1 {
		fmt.Println("Reading data on channel")
		fmt.Println("Received   " + msg)
	}
	close(ch1)

}
func write(ch1 chan string){
	// in for loop write data to channel 
	for i:=1;i<count;i++{
		fmt.Println("Sending data to channel " , i)
		ch1 <- "str"+strconv.Itoa(i)
		fmt.Println("Finished sending data to channel " , i)
	}
	
}
