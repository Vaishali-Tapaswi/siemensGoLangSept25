Lab3 - Mutex + wg 
package main

import (
	"fmt"
	"time"
	"sync"
)

const counter = 100

type Bank struct {
	balance float64	
	mymutext sync.Mutex
}

func (b *Bank) Increament(amount float64) {
	b.mymutext.Lock()
	defer b.mymutext.Unlock()
	for j := 0; j < counter; j++ {
		tmp := b.balance + amount
		time.Sleep(1 * time.Millisecond)	
		b.balance = tmp
	}
	fmt.Println("In Increment - current balance is ", b.balance)
}

func (b *Bank) Decrement(amount float64) {
	b.mymutext.Lock()
	defer b.mymutext.Unlock()
	
	for j := 0; j < counter; j++ {
		tmp := b.balance - amount
		time.Sleep(1 * time.Millisecond)	
		b.balance = tmp
	}
	fmt.Println("In Decrement - current balance is ", b.balance)
}

func main() {
	var wg sync.WaitGroup
	bank := Bank{balance: 0.0}
	wg.Add(1)
	wg.Add(1)

	go func(){
		defer wg.Done()
		bank.Increament(1)
	}()
	go func(){
		defer wg.Done()
		bank.Decrement(1)
	}()
	
	fmt.Println("before wait")
	wg.Wait()
	fmt.Println("after wait")
	fmt.Printf("Final balance for account is %.2f\n", bank.balance)
	
}


Lab2 - why synchronization
package main

import (
	"fmt"
	"time"
)

const counter = 100

type Bank struct {
	balance float64	
}

func (b *Bank) Increament(amount float64) {
	for j := 0; j < counter; j++ {
		tmp := b.balance + amount
		time.Sleep(5 * time.Millisecond)
		b.balance = tmp
	}
	fmt.Println("In Increment - current balance is ", b.balance)
}

func (b *Bank) Decrement(amount float64) {
	for j := 0; j < counter; j++ {
		tmp := b.balance - amount
		time.Sleep(5 * time.Millisecond)	
		b.balance = tmp
	}
	fmt.Println("In Decrement - current balance is ", b.balance)
}

func main() {
	bank := Bank{balance: 00.0}
	for i := 0; i < 5; i++ {
		go bank.Increament(1)
		go bank.Decrement(1)
	}
	time.Sleep(5 * time.Second)
	fmt.Printf("Final balance for account is %.2f\n", bank.balance)
}


Lab1 - goroutine interaction, range for channel reading 
package main 
import (
	"fmt"
	"strconv"
)
const count=50

func main(){
		ch := make(chan string)
		go write(ch)
		go read(ch)
		for{

		}
}

func read(ch1 chan string){
	/*Option for fixed number of messages
	for i:=1;i<5;i++{
		fmt.Println("Reading data on channel")
		str := <-ch1 
		fmt.Println("Received   " + str)
	}
	*/
	for msg := range ch1 {
		fmt.Println("Reading data on channel")
		fmt.Println("Received   " + msg)
	}
	close(ch1)

}
func write(ch1 chan string){
	// in for loop write data to channel 
	for i:=1;i<count;i++{
		fmt.Println("Sending data to channel " , i)
		ch1 <- "str"+strconv.Itoa(i)
		fmt.Println("Finished sending data to channel " , i)
	}
	
}
