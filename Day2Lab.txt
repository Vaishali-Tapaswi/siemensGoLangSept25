Lab11 - channel 
package main 
import ("fmt"
"time"
)
const count=5000

func main(){
	//var ch chan int
	ch := make(chan int)
	go add(1000,30000, ch)
	//wait for answer 
	fmt.Println("Waiting for channel data .........") 
	calsum := <-ch
	fmt.Println("Got  channel data ......... ", calsum)  
	//calsum = <-ch
	//fmt.Println("Got  channel data ......... ", calsum)  
	for{}
}

func add(n1, n2 int, ch1 chan int) {
	fmt.Println("Calculating ......")
	time.Sleep(1 * time.Second)
	fmt.Println("Sending item1......")
	sum := n1+ n2
	ch1 <- sum
	fmt.Println("Sending item2......")
	ch1 <- n1-n2
	fmt.Println("Finished sending data")
}

Lab10 - go routines, time slicing 
	Create a folder demo4
	Create Lab1.go 
		package main 
		import "fmt"
		const count=5000
		func main(){
			fmt.Println("Enter a key to continue / stop")
		
			go printdetails("-")
			go printdetails("*")
			go printdetails("x")
			fmt.Println("End of main")
		
			//Stop main program from close 
			//Options - infinite for loop, scan, sleep 
			//for{}
			n:=0
			fmt.Scan(&n)
			
		}
		
		func printdetails(str string){
			for i:=1;i<count;i++{
				fmt.Print(str)
			}
		}
	
Lab9 - write code to download https://jsonplaceholder.typicode.com/todos/1 json file 
			just show title 
	   write code to download https://jsonplaceholder.typicode.com/todos json file, use range method to show table of todos 
		
Lab8 - 
	struct -> type Emp struct {
				 EmpNo  int
				 Name   string
				 Salary float64
				}
	Convert variable to emp to JSON 
	convert EmpJson to object 
	lib - encoding/json

package main

import (
 "encoding/json"
 "fmt"
)

type Emp struct {
	EmpNo int     `json:"empno"`
	Name  string  `json:"name"`
	Salary   float64 `json:"sal"`
}

func main() {

 emp1 := Emp{
  EmpNo:  101,
  Name:   "Vikram",
  Salary: 75000.50,
 }

 fmt.Printf("Original Struct: %+v \n", emp1)

 jsonEmp, err := json.Marshal(emp1)
 fmt.Println("JSON String: ", string(jsonEmp), " Error: ", err)
 err = json.Unmarshal(jsonEmp, &emp1)
 fmt.Println("Unmarshal Error: ", err)
 fmt.Printf("Unmarshalled Struct: %+v", emp1)

}



Lab7 - create http client 
package main

import (
	"fmt"
	"net/http"
	"os"
	"io"
)
func main() {
	url:="https://jsonplaceholder.typicode.com/todos/" + os.Args[1]
	resp, err := http.Get(url)
	fmt.Println("Done ")
	fmt.Println(" err ", err)
	fmt.Println("Status = ", resp.Status)
	b, err := io.ReadAll(resp.Body)
	fmt.Println("Body COntent " ,string(b) , err)
}

Lab6 - create http server 
package main

import (
	"fmt"
	"net/http"
	"io"
)

func main() {

	http.HandleFunc("/",
		func(w http.ResponseWriter, r *http.Request) {
			//fmt.Fprintf(w, "<h1>Index Page</h1>")
			w.Write([]byte("Hello World !!"))
			
		})
	http.HandleFunc("/hello",
		func(w http.ResponseWriter, r *http.Request) {
			fmt.Fprintf(w, "<h1>Hello Page !!</h1>")
		})
	
	http.HandleFunc("/simple",
		func(w http.ResponseWriter, r *http.Request) {
			io.WriteString(w, "<body bgcolor='cyan'>Hello</body>")
		})

		

	fmt.Println("Starting Server on 8080...")
	http.ListenAndServe(":8080", nil)
}


Lab5 - module and external library 
	create a folder - Lab5readprops
	create two files 
		config.properties 
			host=localhost
			port=8080
	Lab1.go
		package main
		import (
			"fmt"
			"github.com/magiconair/properties"
		)
		func main(){
				p := properties.MustLoadFile("./config.properties", properties.UTF8)
				v := p.GetString("host", "default value can't read prop file")
				fmt.Println(v)
				port := p.GetInt32("port", 80)
				fmt.Println(port)
		}
	cmd in Lab5readprops>go run Lab1.go 
		check error 
	cmd>go mod init nameofmodule 
		observe go.mod file getting created
	cmd>go mod tidy 
		observe go.mod file modified to include magiconair refernce and go.sum created 
	cmd>go run . 
		(any go file main.main will be executed)

Lab4 - write Lab4 
		func main to invoke input, calc
		in function input -> accept input from user - two strings 
		in function calculate -> accept two inputs both strings, divide and return int 
	func main(){
	str1,str2:= input()
	calculate(str1,str2)
}
func input() (str1,str2){
	print messages
	accept two strings to be converted to numbers later 
}
func calculate(str1, str2){
	//import strconv 
	no1, _ = strconv.Atoi(str1)
	no2, _ = strconv.Atoi(str2)
	return no1/no2
	
}
	Step1 - complete and run code without any error handling 
    Step2 - register some calls to defer one in main other in calculate
		pass wrong params (1 string param 2 second argument zero) -> watch error 
    Step3 - write recover to just show message

Lab3 - recover 
package main 

import "fmt"

func main(){
	defer fmt.Println("..............Defer in main")
	defer test()
	fmt.Println("Starting main ")
	demo(4)
	fmt.Println("Ending  main ")
}
func test() {
	r := recover();
	fmt.Println("in test function, current r is " , r)
    if  r != nil {          fmt.Println("Recovered in test function ", r)}
    }
func demo(i int) {
	defer fmt.Println("............trying to catch exception")
	fmt.Println("starting line in g")
    if i > 3 {
		fmt.Println("Panicking!")
        panic(fmt.Sprintf("Panic statement %v", i))
    }
	fmt.Println("ending line in Printing in g", i)
}

Lab2 - panic 
package main 

import "fmt"

func main(){
	defer fmt.Println("..............Defer in main")
	fmt.Println("Starting main ")
	demo(4)
	fmt.Println("Ending  main ")
}
func demo(i int) {
	defer fmt.Println("............trying to catch exception")
	fmt.Println("starting line in g")
    if i > 3 {
		fmt.Println("Panicking!")
        panic(fmt.Sprintf("Panic statement %v", i))
    }
	
	fmt.Println("ending line in Printing in g", i)
}


Lab1 - Create folder Demo3
      Lab1.go
package main 

import "fmt"

func main(){
	defer fmt.Println("Defer statement of main ")
	fmt.Println("Hello")
	print()
	fmt.Println("World")
	for  i :=0;i<5;i++ {
		defer fmt.Println("Main - ", i)
		}
}

func print(){
	i := 10
	defer fmt.Println("Closing Resources ", i)
	fmt.Println("print - line1")
	fmt.Println("print - line2")
	i = 1000
}

Check defer stacking
